一般情况下系统良好运行的时候恰恰各项资源达到了一个平衡体，任何一项资源的过渡使用都会造成平衡体系破坏，从而造成系统负载极高或者响应迟缓。比如CPU过渡使用会造成大量进程等待CPU资源，系统响应变慢，等待会造成进程数增加，进程增加又会造成内存使用增加，内存耗尽又会造成虚拟内存使用，使用虚拟内存又会造成磁盘IO增加和CPU开销增加。

影响性能的因素

1）CPU（cpu的速度与性能很大一部分决定了系统整体的性能，是否使用SMP）

2）内存（物理内存不够时会使用交换内存，使用swap会带来磁盘I0和cpu的开销）

3）硬盘（存储系统）

# 相关指标

## swap

swap会带来磁盘I0和cpu的开销, 很多服务器关闭了swap

>   swapon -s命令查看当前系统上正在使用的交换空间有哪些，以及相关信息

## 磁盘

磁盘IO瓶颈问题：生成cache文件，数据库频繁更新，或者查询大表

## cpu

## 上下文切换

CPU 的上下文切换就可以分为几个不同的场景，也就是**进程上下文切换、线程上下文切换以及中断上下文切换**。

Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，CPU 特权等级的 Ring 0 和 Ring 3。进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。
从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。
**内核空间（Ring 0）**具有最高权限，可以直接访问所有资源；
**用户空间（Ring 3）**只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

>   系统调用的过程有没有发生 CPU 上下文的切换呢？答案自然是肯定的

CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，
CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务 >
而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了**两次 CPU 上下文切换。**

系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：

>   进程上下文切换，是指从一个进程切换到另一个进程运行。而系统调用过程中一直是同一个进程在运行

所以，系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免

>   进程上下文切换和系统调用的区别

进程是由内核来管理和调度的，**进程的切换只能发生在内核态。**所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。
因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成

[![img](https://cdn.jsdelivr.net/gh/JasonsteagleWu/picgo_01/20190731191404.png)](https://cdn.jsdelivr.net/gh/JasonsteagleWu/picgo_01/20190731191404.png)

**每次上下文切换都需要几十纳秒到数微秒的 CPU 时间**。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是上一节中我们所讲的，导致平均负载升高的一个重要因素。

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程

>   Cpu 调度

+   为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切
    换到其它正在等待 CPU 的进程运行。
+   进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
+   当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
+   当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
+   发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

>   vmstat 查看

cs（context **switch**）是每秒上下文切换的次数。 

**in**（interrupt）则是每秒中断的次数。

r（Running **or** Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。 

b（Blocked）则是处于不可中断睡眠状态的进程数 

>   pidstat 查看每个进程的详细情况   
>
>   -d     Report I/O statistics
>
>   -u     Report CPU utilization.
>
>   -w     Report task switching activity

查看单个进程的pidstat -w 1

```
[root@education_01 ~]# pidstat -w 1
Linux 3.10.0-957.27.2.el7.x86_64 (education_01) 	03/15/2021 	_x86_64_	(4 CPU)

05:56:37 PM   UID       PID   cswch/s nvcswch/s  Command
05:56:38 PM     0         9     69.00      0.00  rcu_sched
05:56:38 PM     0       411      9.00      0.00  kworker/1:1H
05:56:38 PM     0       412     10.00      0.00  jbd2/vda1-8
05:56:38 PM  1000       888      1.00      0.00  uwsgi
05:56:38 PM     0      1467     10.00      0.00  redis-server
05:56:38 PM     0      4305      2.00      0.00  docker-proxy
05:56:38 PM     0      4333      1.00      0.00  tini
05:56:38 PM     0      4465      1.00      0.00  sshd
05:56:38 PM  1000      4696      3.00      0.00  node
05:56:38 PM     0      6361      1.00      0.00  kworker/u8:2
05:56:38 PM     0      8604      1.00      0.00  kworker/0:1
05:56:38 PM     0     10913      3.00      0.00  kworker/3:1
05:56:38 PM     0     13680      1.00      0.00  kworker/1:2
05:56:38 PM     0     13694      1.00      0.00  pidstat
05:56:38 PM     0     21874      3.00      0.00  kworker/1:0
05:56:38 PM     0     28817      1.00      0.00  kworker/2:0
05:56:38 PM   472     31268      1.00      0.00  grafana-server
```

## 查看/proc/interrupts ，查看中断使用情况

/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情

watch -d cat /proc/interrupts

可以通过vmstat 、 pidstat 和 /proc/interrupts 等工具，来辅助排查性能问题的根源

## 内存







[Fio压测工具和io队列深度理解和误区](https://blog.csdn.net/niepangu/article/details/52474940)

[fio工具中的iodepth参数与numjobs参数-对测试结果的影响](https://blog.csdn.net/qq_14935437/article/details/93752448)

[Linux性能分析之上下文切换](https://www.cnblogs.com/mrwuzs/p/11279511.html)

[趣谈linux操作系统笔记-内核初始化](https://www.cnblogs.com/mrwuzs/p/11275623.html)

https://www.cnblogs.com/mrwuzs/tag/Linux/





[深入理解iostat](https://blog.csdn.net/Cooder_SXK/article/details/104437350)

[vmstat：一个标准的报告虚拟内存统计工具](https://linux.cn/article-8157-1.html)



[深入理解linux系统下proc文件系统内容](https://www.cnblogs.com/cute/archive/2011/04/20/2022280.html)





