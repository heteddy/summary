# SMP

为了扩展单核 CPU 的性能，现在的服务器架构多采用多核 CPU 架构。一个比较经典的 CPU 架构就是**对称多处理**（Symmetric Multi-Processing，SMP）架构。与之相对应的就是**非对称多处理**（Asym-metrical Mulit-Processing）结构。

这个**对称**是什么意思？即处理器与处理器的关系，在**对称多处理架构**中，处理器之间是相同等级的，所有处理器都可以访问相同的资源。与之相应的，**非对称多处理架构**，各处理器之间形成简单的主从设备关系，访问有限的资源。

一个 SMP CPU 架构如下所示：



![img](https://pic4.zhimg.com/80/v2-eec88d0bc5021f23d175168396792a67_1440w.jpg)



现代的 CPU 一般会有多个**核心**（Core），我们这里是两个。每个核心有各自的 **L1 Cache**，多个核心共享 **L2 和 L3 Cache**。CPU 通过**前端总线**（FSB）访问主内存。多个 CPU 对于内存访问是基于缓存行的，多个 CPU 对于内存的访问符合**缓存一致性协议**(Cache coherency protocol)。SMP 架构中，系统中所有资源都是共享的，由于多个 CPU 对于同一个前端总线的竞争，导致扩展能力有限。在超过 64 个 CPU 以上的机器中，这个问题会愈发严重。在大型服务器中，主流架构一般是 NUMA（Non-Uniform Memory Access，非一致存储访问）。



# SMP和NUMA 

## 通用的多核CPU架构

![img](https://pic2.zhimg.com/80/v2-44129f0798b4e604eb49a611faff5e0d_1440w.jpg)

在多核 CPU 中，每个核都有自己的私有缓存，这样才能达到最佳的性能，如果所有的核都共用同一个缓存，缓存的吞吐跟不上。所以现在CPU都有 L1，L2，L3三级缓存，L1和L2缓属于同一个CPU核，L3则是所有CPU核心所共享。L1、L2、L3的越离CPU核心越近，速度也越快，当然价格也越高，所以容量就越小。一般来讲，L1 的读取速率为 4 个CPU[时钟](https://link.zhihu.com/?target=http%3A//www.elecfans.com/tags/%E6%97%B6%E9%92%9F/)周期 L2 为 11 L3 为 39 内存为107 个CPU时钟周期。L1的大小一般为32KB，L2大小为256KB,L3为MB级别的。服务器可以达到24MB.

## 多处理器的架构

![img](https://pic2.zhimg.com/80/v2-fb75f86244a599e085f74c2c3a4ab571_1440w.jpg)

SMP架构 随着更多的处理器被添加到SMP系统中，总线的竞争将会越来越大，系统的性能也必将随之大打折扣

![img](https://pic3.zhimg.com/80/v2-03cacc8040302f1075cf4e49cb9e593a_1440w.jpg)

NUMA架构 NUMA架构在逻辑上也遵从对称多处理（SMP）架构，在NUMA架构，CPU访问和他自己同一Chip的内存速度比访问其他Chip的内存要快3倍左右，Linux内核默认使用CPU亲和的内存分配策略，使内存页尽可能的和调用线程处在同一个Core/Chip，所有这些都使得NUMA架构成了高性能的流行解决方案。

## CPU缓存行与伪共享的问题

缓存行是CPU Cache中的最小缓存单位，目前主流的CPU Cache的缓存行大小都是64B。如果我们需要缓存一个256字节的数据，这个一级缓存所能存放的缓存个数就是256/64 = 4个。

如果有的变量不足64Bytes，这时候有可能有多个变量共享缓存行。

当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会互相影响，这就是伪共享，缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。

![img](https://pic1.zhimg.com/80/v2-429693d7eb333a75e0f34c6330532360_1440w.jpg)图片来源网络

如上图在core1上的线程要更新变量X，同时core2上的线程要更新变量Y。但是，不巧的是这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果core1获得了所有权，缓存子系统将会使core2中对应的缓存行失效。如果core2获得了所有权然后执行更新操作，core1就要使自己对应的缓存行失效。这样需要多次经过L3缓存，影响了性能。

后续专门阐述如何解决伪共享的问题。

## 4 CPU缓存一致性问题

为了提高CPU的处理效率，cpu不会直接和内存交换数据，都会先经过缓存(L1,L2,L3),在什么写回内存并确定，考虑到以下场景：core1 读取了一个变量x，以及x和它相邻的字节被读入core1 的高速缓存，core2 也同样读取了变量x，讲x和相邻的字节存入core2的高速缓存。这样 core1 ， core2 的高速缓存拥有同样的数据。core1 修改了那个变量x，修改后，变量被放回 CPU1 的高速缓存行。但是该信息并没有被写回主内存 ，core2 访问该变量x，但由于 CPU1 并未将数据写入 RAM ，导致了数据不同步。

为了解决这个问题，设计者制定了一些规则，这就是缓存一致性协议MESI。

MESI 是缓存协议4个状态的首字母：

![img](https://pic3.zhimg.com/80/v2-b9d00b5f3ff3787a5ca0a1af7c5b23b2_1440w.jpg)

图片来源网络

后续详细讲解MESI协议。





[13 种在 Linux 系统上检测 CPU 信息的工具](https://cloud.tencent.com/developer/article/1114984)